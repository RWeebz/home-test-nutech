import { sql } from 'drizzle-orm';

/**
 * Get user balance by user ID
 * @param {Object} db_conn - Database connection
 * @param {number} userId - User ID
 * @returns {Promise<Object>} Balance object
 */
export async function getBalance(db_conn, userId) {
  const result = await db_conn.execute(
    sql`SELECT balance FROM user_balance WHERE user_id = ${userId} LIMIT 1`
  );

  if (result.rows.length === 0) {
    throw new Error('User not found');
  }

  return result.rows[0];
}

/**
 * Get transaction type ID by type name
 * @param {Object} db_conn - Database connection or transaction
 * @param {string} typeName - Transaction type name ('TOPUP' or 'PAYMENT')
 * @returns {Promise<number>} Transaction type ID
 */
async function getTransactionTypeId(db_conn, typeName) {
  const result = await db_conn.execute(
    sql`SELECT id FROM transaction_type_enum WHERE transaction_type = ${typeName} LIMIT 1`
  );

  if (result.rows.length === 0) {
    throw new Error(`Transaction type ${typeName} not found`);
  }

  return result.rows[0].id;
}

/**
 * Top up user balance
 * @param {Object} tx - Database transaction
 * @param {number} userId - User ID
 * @param {number} amount - Top up amount
 * @returns {Promise<Object>} Updated balance and transaction record
 */
export async function topUpBalance(tx, userId, amount) {
  // Validate amount
  if (amount <= 0) {
    throw new Error('Paramter amount hanya boleh angka dan tidak boleh lebih kecil dari 0');
  }

  // Get current balance
  const balanceResult = await tx.execute(
    sql`SELECT balance FROM user_balance WHERE user_id = ${userId} LIMIT 1`
  );

  if (balanceResult.rows.length === 0) {
    throw new Error('User not found');
  }

  const currentBalance = balanceResult.rows[0].balance;
  const newBalance = currentBalance + amount;

  // Update balance
  await tx.execute(
    sql`UPDATE user_balance SET balance = ${newBalance} WHERE user_id = ${userId}`
  );

  // Get transaction type ID for TOPUP
  const transactionTypeId = await getTransactionTypeId(tx, 'TOPUP');

  // Create transaction record (invoice_number will be auto-generated by database trigger)
  const transactionResult = await tx.execute(
    sql`INSERT INTO user_transactions (user_id, invoice_number, service_id, description, transaction_type_id, total_amount, created_on)
        VALUES (${userId}, NULL, NULL, 'Top Up balance', ${transactionTypeId}, ${amount}, NOW())
        RETURNING *`
  );

  return {
    balance: newBalance,
    transaction: transactionResult.rows[0]
  };
}

/**
 * Get service by service code
 * @param {Object} db_conn - Database connection
 * @param {string} serviceCode - Service code
 * @returns {Promise<Object>} Service object
 */
export async function getServiceByCode(db_conn, serviceCode) {
  const result = await db_conn.execute(
    sql`SELECT * FROM services WHERE code = ${serviceCode} LIMIT 1`
  );

  if (result.rows.length === 0) {
    throw new Error('Service ataus Layanan tidak ditemukan');
  }

  return result.rows[0];
}

/**
 * Create a transaction (payment)
 * @param {Object} tx - Database transaction
 * @param {number} userId - User ID
 * @param {string} serviceCode - Service code
 * @returns {Promise<Object>} Transaction record with service details
 */
export async function createTransaction(tx, userId, serviceCode) {
  // Get service
  const service = await getServiceByCode(tx, serviceCode);

  // Get current balance
  const balanceResult = await tx.execute(
    sql`SELECT balance FROM user_balance WHERE user_id = ${userId} LIMIT 1`
  );

  if (balanceResult.rows.length === 0) {
    throw new Error('User balance not found');
  }

  const currentBalance = balanceResult.rows[0].balance;

  // Check balance
  if (currentBalance < service.tariff) {
    throw new Error('Balance tidak mencukupi');
  }

  const newBalance = currentBalance - service.tariff;

  // Update balance
  await tx.execute(
    sql`UPDATE user_balance SET balance = ${newBalance} WHERE user_id = ${userId}`
  );

  // Get transaction type ID for PAYMENT
  const transactionTypeId = await getTransactionTypeId(tx, 'PAYMENT');

  // Create transaction record (invoice_number will be auto-generated by database trigger)
  // Use service name as description
  const transactionResult = await tx.execute(
    sql`INSERT INTO user_transactions (user_id, invoice_number, service_id, description, transaction_type_id, total_amount, created_on)
        VALUES (${userId}, NULL, ${service.id}, ${service.name}, ${transactionTypeId}, ${service.tariff}, NOW())
        RETURNING *`
  );

  // Get transaction type name
  const transactionTypeResult = await tx.execute(
    sql`SELECT transaction_type FROM transaction_type_enum WHERE id = ${transactionTypeId} LIMIT 1`
  );

  // Return transaction with service details and transaction type
  return {
    ...transactionResult.rows[0],
    service_code: service.code,
    service_name: service.name,
    transaction_type: transactionTypeResult.rows[0].transaction_type
  };
}

/**
 * Get transaction history for a user
 * @param {Object} db_conn - Database connection
 * @param {number} userId - User ID
 * @param {number} offset - Pagination offset (default: 0)
 * @param {number} limit - Pagination limit (default: 5, null for all)
 * @returns {Promise<Object>} Transaction history with pagination info
 */
export async function getTransactionHistory(db_conn, userId, offset = 0, limit = 5) {
  // Build query based on whether limit is provided
  let transactionsResult;
  if (limit !== null && limit > 0) {
    transactionsResult = await db_conn.execute(
      sql`SELECT
            ut.invoice_number,
            tte.transaction_type,
            ut.description,
            ut.total_amount,
            ut.created_on
          FROM user_transactions ut
          INNER JOIN transaction_type_enum tte ON ut.transaction_type_id = tte.id
          WHERE ut.user_id = ${userId}
          ORDER BY ut.created_on DESC
          LIMIT ${limit} OFFSET ${offset}`
    );
  } else {
    transactionsResult = await db_conn.execute(
      sql`SELECT
            ut.invoice_number,
            tte.transaction_type,
            ut.description,
            ut.total_amount,
            ut.created_on
          FROM user_transactions ut
          INNER JOIN transaction_type_enum tte ON ut.transaction_type_id = tte.id
          WHERE ut.user_id = ${userId}
          ORDER BY ut.created_on DESC
          OFFSET ${offset}`
    );
  }

  return {
    offset: offset,
    limit: limit,
    records: transactionsResult.rows
  };
}
